This chapter starts with a discussion regarding the validity of the results and the
possibility of using these to draw more general conclusions. Furthermore the results
and what conclusions can be drawn from these are discussed. Finally, some
suggestions for future research is given.

\section{Validity of the results}\label{sec:validity}
Two main criticisms concerning the validity of the results can be raised:
\begin{enumerate}
\item Only a few number of queries were used for evaluation;
\item And only one dataset was used for evaluation.
\end{enumerate}

Both of these criticisms will be answered in turn below. Finally a motivation
is provided as to why the results can be considered possible to draw general
conclusions from.

\subsection{Only a few queries were used}
\textit{Only one single query and subsets of that query were used, this is hardly a
  large set of tests for evaluation.}

To answer this criticism it is important to consider the fact that the
possibility for multiple access methods for the same relation depends on the
criteria outlined in Section~\ref{sec:dataset}. The tables fulfilling these
criteria are few, reducing the possibility to use multiple queries as they will
only involve the same tables anyway.

Furthermore, the query constructed can be considered to be sufficiently complex
to be problematic for the query optimizer, while not being unreasonably
contrived. This means that if the problem does not arise for the query, it is
highly unlikely to do so for a simpler query --- and of little interest if it
does for a more complex query.

So while only one query and subsets of it are used, they cover a good interval
of simple to reasonably complex for the query optimizer to handle. This means that the
results from these can be considered valid.

\subsection{Only one dataset was used}
\textit{Only one dataset was used for evaluation, the results found for the
  problem studied could be very different for another dataset.}

This criticism is one related to the problem of evaluating databases in general:
the performance of the database is often dependent on the dataset used for
testing. While it is correct that the results could vary depending on dataset,
this problem applies to all studies of databases.

Furthermore, the dataset used to test the databases is one taken from the real
world, making it more realistic than those often otherwise used. As such, the
validity of the results of this study are well on par with those of other
studies using less realistic datasets like TPC-H.

So while only one dataset is used, the results found are realistic and well on
par with that of other studies on the subject of databases.

\subsection{Applicability}
The results found in this study do, as all other studies of databases do, suffer
from the problem of the possibility of the results depending on the dataset
used. However, the results found in this study show two things:
\begin{itemize}
\item Different access methods are used to access the same relation;
\item And the behavior of when this is done differs between MariaDB and
  PostgreSQL.\@
\end{itemize}

Neither of these results is tied to the specific dataset used, instead they are
both show behavior that will very likely arise for more datasets. Adding more
datasets could only answer the question of the prevalence of the behavior.

\section{Selection of access method}\label{sec:accessmethods}
This section will discuss the main findings of the evaluation, starting with a
discussion regarding the correlation between sample size and the number of
different access methods used for the same relation. Following this a section
describing the second set of results identified: the correlation between
predicate value and access methods used.

\subsection{Sample size in correlation to different access methods used}
The main purpose of the study was to identify a correlation between the effect
of cost estimation on the access methods selected by the query optimizer. As a
way to evaluate this the number of samples used when analyzing and
generating the cardinality estimates is varied from a low to a high value.

The results of this evaluation can be seen in Figure~\ref{fig:plot:eval1:test1},
which shows the test done with a low sample size, and
Figure~\ref{fig:plot:eval1:test2}, which shows the test with the high sample size.
It is clear that MariaDB performs the same regardless of sample size as the
access methods used for all relations remain the same, regardless of sample size.

This result clearly indicates that while MariaDB selects different access
methods, it doesn't seem to do so because of varying estimations of the
cardinality. Rather, it must be something else that determines it. This
warranted another evaluation and the discussion regarding that can be seen in
Section~\ref{sec:predicatecorrelation}.

Apart from this finding it is also clear that MariaDB and PostgreSQL don't
perform in the same way; for example MariaDB always selects the same access method for
the relation \textit{mt} --- whereas PostgreSQL varies between two different access
methods.

Another difference between the two query optimizers is that MariaDB always uses an
index if one exists, whereas PostgreSQL will sometimes do a full table scan
instead of using an index.

Additionally PostgreSQL does not use different indexes for \textit{ct}, unlike
MariaDB which varies between three different indexes. This behavior is further
evaluated in the second evaluation (see Section~\ref{sec:subsets} for the
results), which is discussed in Section~\ref{sec:predicatecorrelation}.

The maybe most important difference that can be seen from the results
is that MariaDB consistently selects the same access methods regardless of
the estimated cardinalities. However, PostgreSQL is more sensitive to estimated
cardinalities, and for example the relation \textit{cmt} has different access methods
with a low sample size but only one when the cardinality can be better
estimated. This differing behavior leads to the question of which is the best
--- always using indexes if they exist, or varying between full table scans and
indexes depending on cardinality estimates?

\subsection{Predicate value in correlation to different access methods used}\label{sec:predicatecorrelation}
From the first evaluation it is clear that both databases will sometimes select different
access methods regardless of the sample size used when estimating cardinalities.
To further evaluate this tests were done with only one repetition, but still
for each possible value for the predicate.

This evaluation shows two things:
\begin{enumerate}
\item The access method used can depend on the predicate value;
\item The behavior differs between the two databases;
\item And the behavior is consistent regardless of the complexity of the query.
\end{enumerate}

Firstly, that the access method depends on the predicate value used can be seen in
Figure~\ref{fig:plot:eval2:test1} where MariaDB has three different access
methods for \textit{ct} and PostgreSQL has two different for \textit{cmt}. Since
there are no repetitions, the only varying parameter is the predicate value.

The fact that the query optimizer is sensitive to the predicate value can be seen as
both intuitive and unintuitive --- the filter factor might vary considerably
depending on the predicate value. At the same time, there should always exist
one index that is the best for accessing the same relation.

Secondly, the behavior differing between the two databases, can be seen in that
MariaDB switches between using different indexes whereas PostgreSQL will
switch between using an index or doing a full table scan. This behavior can be
seen for the relation \textit{cmm} which has two possible access methods --- via
an index on the primary key or a full table scan; PostgreSQL will switch between
the two while MariaDB will consistently use only the index.

Thirdly and finally, the behavior being consistent regardless of the complexity
of the query, can be seen in Figure~\ref{fig:plot:eval2:test9} which is a simple
query on a single relation. Even so, MariaDB will still vary between three
different indexes based only on the predicate value. For PostgreSQL the behavior
can be observed in Figure~\ref{fig:plot:eval2:test4}, which is the least complex
query used involving the relation \textit{cmt}.

The fact that the behavior can be seen even for simpler queries indicate that it
is not caused by the query optimizer acting incorrectly due to the query being
too complex. Instead it seems to be a deliberate choice by both of the query
optimizers.

\section{Future research}
This section will cover some suggestions for future research on the topic of
databases, both in general and specifically for the problem of selecting access method.

As discussed in Section~\ref{sec:validity} one problem when evaluating
databases is the dataset used for evaluation. In this study a dataset based on a
product for the company TriOptima was used to evaluate the databases with a real-world
dataset. However, this dataset can't be made public. Other datasets, like TPC-H
or the more recent JOB, suffer from the problem that they are simpler
than a database used by a company; as an example both of them have only one
index per relation on the primary key.

One important area of research in databases would therefore be to create one or
more realistic datasets with complex data, relations and indexes that could be
used for research. Using these datasets for evaluation would then provide
results that could be considered more general and correct.

The focus of this thesis was the correlation between the quality of the
statistics used in the cost estimation and the access methods chosen. The
results found for this show that MariaDB consistently selects indexes if they
exist, never opting to do a full table scan. On the other hand, PostgreSQL is more
sensitive to cardinality estimates and will sometimes opt to do a full table
scan instead. This shows a clear difference in behavior and one that could be
further evaluated --- which is the best behavior out of the two?

Finally this study show that both database's query optimizers select
different access methods depending on predicate value and that the two do so
differently. This also leads to the question of if this is the correct behavior
or not.
